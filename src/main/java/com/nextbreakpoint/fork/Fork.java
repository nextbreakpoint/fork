package com.nextbreakpoint.fork;

import com.nextbreakpoint.Try;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Future;
import java.util.function.Function;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * Fork implements a fluent API for executing tasks in parallel and collecting results.
 * 
 * @author Andrea Medeghini
 *
 * @param <T> the type of returned value
 * @param <E> the type of captured exception
 */
public class Fork<T, E extends Throwable> {
	private final Function<Throwable, E> mapper;
	private final ExecutorService executor;
	private final List<Future<T>> futures;

	/**
	 * Creates new instance with given executor, mapper and class. 
	 * The executor service will be used to execute the submitted tasks. 
	 * The mapper is required to transform any exception generated by the task into the expected exception.
	 * The class is required to specify the type returned by a task.
	 * @param executor the executor
	 * @param mapper the mapper
	 * @param clazz the class
	 * @return new instance
	 */
	public static <T, E extends Throwable> Fork<T, E> of(ExecutorService executor, Function<Throwable, E> mapper, Class<T> clazz) {
		return new Fork<T, E>(executor, mapper, Collections.emptyList());
	}

	/**
	 * Creates new instance with given executor and class. 
	 * The executor service will be used to execute the submitted tasks. 
	 * The class is required to specify the type returned by a task.
	 * @param executor the executor
	 * @param clazz the class
	 * @return new instance
	 */
	public static <T> Fork<T, Throwable> of(ExecutorService executor, Class<T> clazz) {
		return of(executor, defaultMapper(), clazz);
	}

	/**
	 * Submit a list of tasks.
	 * @param tasks the list of tasks
	 * @return new instance
	 */
	public Fork<T, E> submit(List<Callable<T>> tasks) {
		return new Fork<T, E>(executor, mapper, merge(futures, tasks.stream().map(task -> executor.submit(() -> task.call())).collect(Collectors.toList())));
	}

	/**
	 * Submit a task.
	 * @param task the task
	 * @return new instance
	 */
	public Fork<T, E> submit(Callable<T> task) {
		return submit(Collections.singletonList(task));
	}

	/**
	 * Returns a stream.
	 * @return new stream
	 */
	public Stream<Try<T, E>> stream() {
		return stream(mapper);
	}

	/**
	 * Returns a stream.
	 * @param mapper the exception mapper
	 * @return new stream
	 */
	public <X extends Throwable> Stream<Try<T, X>> stream(Function<Throwable, X> mapper) {
		return futures.stream().map(future -> join(mapper, future));
	}

	private Fork(ExecutorService executor, Function<Throwable, E> mapper, List<Future<T>> futures) {
		this.executor = executor;
		this.futures = futures;
		this.mapper = mapper;
	}

	private <X extends Throwable> Try<T, X> join(Function<Throwable, X> mapper, Future<T> future) {
		return Try.of(mapper, () -> future.get());
	}

	private List<Future<T>> merge(List<Future<T>> list1, List<Future<T>> list2) {
		ArrayList<Future<T>> list = new ArrayList<>();
		list.addAll(list1);
		list.addAll(list2);
		return list;
	}

	private static Function<Throwable, Throwable> defaultMapper() {
		return x -> x;
	}
}
