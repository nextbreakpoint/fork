package com.nextbreakpoint.fork;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Future;
import java.util.function.Function;
import java.util.stream.Collector;
import java.util.stream.Collectors;

import com.nextbreakpoint.Try;

/**
 * Fork implements a functional API for executing parallel tasks in Java 8.
 * 
 * @author Andrea
 *
 * @param <T> the type of returned value
 * @param <E> the type of captured exception
 */
public class Fork<T, E extends Throwable> {
	private final Function<Throwable, E> mapper;
	private final ExecutorService executor;
	private final List<Future<T>> futures;

	/**
	 * Creates new instance with given executor, mapper and class. 
	 * The executor service will be used to execute the submitted tasks. 
	 * The mapper is required to transform any exception generated by the task into the expected exception.
	 * The class is required to specify the type returned by a task.
	 * @param executor the executor
	 * @param mapper the mapper
	 * @param clazz the class
	 * @return
	 */
	public static <T, E extends Throwable> Fork<T, E> of(ExecutorService executor, Function<Throwable, E> mapper, Class<T> clazz) {
		return new Fork<T, E>(executor, mapper, Collections.emptyList());
	}

	/**
	 * Creates new instance with given executor and class. 
	 * The executor service will be used to execute the submitted tasks. 
	 * The class is required to specify the type returned by a task.
	 * @param executor the executor
	 * @param clazz the class
	 * @return
	 */
	public static <T> Fork<T, Throwable> of(ExecutorService executor, Class<T> clazz) {
		return of(executor, defaultMapper(), clazz);
	}

	/**
	 * Submit a list of tasks.
	 * @param tasks the tasks
	 * @return new instance
	 */
	public Fork<T, E> submit(List<Callable<T>> tasks) {
		return new Fork<T, E>(executor, mapper, merge(futures, tasks.stream().map(task -> executor.submit(() -> task.call())).collect(Collectors.toList())));
	}

	/**
	 * Submit a single task.
	 * @param task the task
	 * @return new instance
	 */
	public Fork<T, E> submit(Callable<T> task) {
		return submit(Collections.singletonList(task));
	}

	/**
	 * Executes all tasks submitted and collects values. 
	 * Continues to collect values when a task throws an exception. 
	 * Passes failureValue to collector when task fails.
	 * Values are collected in same order as tasks are submitted.
	 * Tasks are executed in parallel according to current executor.
	 * @param collector the collector
	 * @param failureValue the value of a failed task
	 * @return the value of collector
	 */
	public <R, A> R collect(Collector<T, A, R> collector, T failureValue) {
		return futures.stream().map(future -> join(mapper, future)).map(v -> v.getOrElse(failureValue)).collect(collector);
	}

	/**
	 * Executes all tasks submitted and collects values. 
	 * Stops collecting values when a task throws an exception. 
	 * Values are collected in same order as tasks are submitted.
	 * Tasks are executed in parallel according to current executor.
	 * @param collector the collector
	 * @return the value of collector
	 */
	public <R, A> Try<R, E> collectOrFail(Collector<T, A, R> collector) {
		try {
			return Try.success(mapper, futures.stream().map(future -> join(e -> new ForkException(e), future)).map(v -> v.getOrThrow()).collect(collector));
		} catch (RuntimeException e) {
			return Try.failure(mapper, mapper.apply(e.getCause()));
		}
	}

	private Fork(ExecutorService executor, Function<Throwable, E> mapper, List<Future<T>> futures) {
		this.executor = executor;
		this.futures = futures;
		this.mapper = mapper;
	}

	private <X extends Throwable> Try<T, X> join(Function<Throwable, X> mapper, Future<T> future) {
		return Try.of(mapper, () -> future.get());
	}

	private List<Future<T>> merge(List<Future<T>> list1, List<Future<T>> list2) {
		ArrayList<Future<T>> list = new ArrayList<>();
		list.addAll(list1);
		list.addAll(list2);
		return list;
	}

	private static Function<Throwable, Throwable> defaultMapper() {
		return x -> x;
	}
	
	private static class ForkException extends RuntimeException {
		private static final long serialVersionUID = 1L;

		public ForkException(Throwable cause) {
			super(cause);
		}
	}
}
